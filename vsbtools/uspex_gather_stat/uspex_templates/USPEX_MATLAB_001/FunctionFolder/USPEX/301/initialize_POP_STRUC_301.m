function initialize_POP_STRUC_301()

% USPEX Version 9.4.0
% Seperate modules
global ORG_STRUC
global POP_STRUC
global POOL_STRUC

% The variable to store number of structures generated with wrong space group:
ORG_STRUC.wrong_spacegroups = 0;

POOL_STRUC = struct('POPULATION',{}, 'Composition_ratio',{}, 'Composition_ranking',{}, 'Composition_surviving',{}, 'Composition_Bestenthalpy',{}, 'Composition_fitness',{}, 'paretoFront',{});
POOL_STRUC(1).POPULATION  = struct('COORDINATES', {}, 'LATTICE', {}, 'numIons', {}, 'numBlocks',{}, 'order', {}, 'enthalpy', {}, 'Number', {});
for i=1:size(ORG_STRUC.numIons,1)
    POOL_STRUC.Composition_ratio(i,:) = ORG_STRUC.numIons(i,:)/sum(ORG_STRUC.numIons(i,:));
    POOL_STRUC.Composition_ranking(i) = 0;
    POOL_STRUC.Composition_surviving(i) = 1;
    POOL_STRUC.Composition_Bestenthalpy(i) = 1000;
    POOL_STRUC.Composition_fitness(i) = 1000;
end
POOL_STRUC.POPULATION(1) = QuickStart(POOL_STRUC.POPULATION);


POP_STRUC = struct('POPULATION',{}, 'SOFTMODEParents',{}, 'SOFTMUTATED',{}, ...
'resFolder', {},'generation',{}, 'DoneOrder',{}, 'bodyCount', {}, 'ranking',{}, 'paretoFront',{}, ...
'bad_rank',{},  'CalcFold',{}, 'CalcFold_max',{}, 'fitness', {}, 'convex_hull',{},  'finalOptimization', {});

POP_STRUC(1).POPULATION = struct('COORDINATES',{},'INIT_COORD',{},'LATTICE',{},'INIT_LAT',{},'numIons',{},'INIT_numIons',{}, ...
    'struc_entr',{},'order',{},'S_order',{},'dielectric_tensor',{}, 'gap',{}, 'hardness',{}, 'symg',{}, ...
    'mag_moment',{}, 'magmom_ions',{}, 'magmom_ini',{}, 'ldaU', {}, 'birefringence', {}, ...
    'TE_property', {}, 'FINGERPRINT',{}, 'K_POINTS',{}, 'Step', {}, 'Enthalpies', {}, 'Error',{},'Done',{},...
    'ToDo',{},'Parents',{},'howCome',{},'JobID',{},'Folder',{}, 'numBlocks', {},'Number',{});
POP_STRUC.POPULATION(1) = QuickStart(POP_STRUC.POPULATION);

POP_STRUC(1).SOFTMUTATED = struct('FINGERPRINT',{}, 'mutatedAt', {}, 'fallBack', {});
POP_STRUC(1).SOFTMODEParents=struct('lattice',{},'coordinates',{},'fingerprint',{},'eignFre',{},'eignVec',{},...
    'Softmode_Fre',{},'Softmode_num',{},'numIons',{},'numBlocks',{});

POP_STRUC.generation = 1;
POP_STRUC.bodyCount = 0;
POP_STRUC.bad_rank = 0;

N_T = size(ORG_STRUC.numIons,1);
IPS = ORG_STRUC.initialPopSize;

fp = fopen('Seeds/compositions', 'w');
if exist('Seeds/Anti-compositions')
    unixCmd('mv Seeds/Anti-compositions Seeds/Anti-compositions-back');
end
for i=1:size(ORG_STRUC.firstGeneSplit,1)
    for j=1:size(ORG_STRUC.firstGeneSplit,2)
        fprintf(fp, '%4d', ORG_STRUC.firstGeneSplit(i,j));
    end
    fprintf(fp, '\n');
end
fclose(fp);

if (ORG_STRUC.firstGeneMax == 0) || (ORG_STRUC.firstGeneMax > IPS)
    ORG_STRUC.firstGeneMax = IPS;
end
if (ORG_STRUC.firstGeneMax > ORG_STRUC.splitN)
    ORG_STRUC.firstGeneMax = ORG_STRUC.splitN;
end
split_rank_temp = randperm(ORG_STRUC.splitN);
split_rank = split_rank_temp;

% we want only different compositions, including all single block compositions
% single elements:
for it = 1 : N_T
    for jt = 1 : ORG_STRUC.splitN
        if sum(ORG_STRUC.firstGeneSplit(split_rank_temp(jt),:)) == ORG_STRUC.firstGeneSplit(split_rank_temp(jt),it)
            split_rank(it) = split_rank_temp(jt);
            split_rank(jt) = split_rank_temp(it);
            split_rank_temp = split_rank;
            break;
        end
    end
end
% identical compositions are moved away till we reach firstGeneMax different ones
cnt = N_T;
split_rank_temp = split_rank;
for it = 1 : ORG_STRUC.splitN
    good_comp = 1; 
    for jt = 1 : cnt
        same = sameComposition(ORG_STRUC.firstGeneSplit(split_rank(jt),:), ORG_STRUC.firstGeneSplit(split_rank_temp(it),:));
        if same == 1
            good_comp = 0;
        end
    end
    if (good_comp == 1) && (size(ORG_STRUC.firstGeneSplit,1) - it) <= (ORG_STRUC.firstGeneMax - cnt)
        good_comp = 1;
    end
    if good_comp == 1
        cnt = cnt + 1;
        split_rank(cnt) = split_rank_temp(it);
        split_rank(it) = split_rank_temp(cnt);
    end
    if cnt >= ORG_STRUC.firstGeneMax
        break;
    end
end 
% at this stage we have firstGeneMax different compositions at the beginning of the population and then whatever was generated by randperm

if ORG_STRUC.firstGeneMax < N_T    % if we found almost no compositions due to strict min/maxAt - at least do all single block ones
    ORG_STRUC.firstGeneMax = N_T;
end
  
 
% vary the number of formula units in the unit cell for same position on the convex hull
% change the algorithm as soon as the number of possible compositions is big enough to slow it down
spl = 1;
for it = 1 : IPS
    while spl > ORG_STRUC.firstGeneMax
        spl = spl - ORG_STRUC.firstGeneMax;
    end
    POP_STRUC.POPULATION(it).numBlocks = ORG_STRUC.firstGeneSplit(split_rank(spl),:);

    % exclude the case of two identical blocks
    % add an element of randomness; numIons for single element compositions can be anything between maxAt and minAt now:
    if N_T > 1      
        if spl <= N_T 
            POP_STRUC.POPULATION(it).numBlocks = zeros(1, N_T); %make sure single block is always single block
            POP_STRUC.POPULATION(it).numBlocks(spl) = round(ORG_STRUC.minAt/sum(ORG_STRUC.numIons(spl,:))) + round(rand*((ORG_STRUC.maxAt-ORG_STRUC.minAt)/sum(ORG_STRUC.numIons(spl,:))));
            while sum(POP_STRUC.POPULATION(it).numBlocks(spl)*ORG_STRUC.numIons(spl,1:end)) > ORG_STRUC.maxAt
                POP_STRUC.POPULATION(it).numBlocks(spl) = POP_STRUC.POPULATION(it).numBlocks(spl) - 1;
                if POP_STRUC.POPULATION(it).numBlocks(spl) < 0
                    break;
                end
            end
            if POP_STRUC.POPULATION(it).numBlocks(spl) < 1
                POP_STRUC.POPULATION(it).numBlocks(spl) = 1;
            end
        else % add an element of randomness if possible
            tmp = POP_STRUC.POPULATION(it).numBlocks;
            for i = 1 : ORG_STRUC.splitN
                same = sameComposition(POP_STRUC.POPULATION(it).numBlocks, ORG_STRUC.firstGeneSplit(i,:));
                if same == 1
                    tmp = vertcat(tmp,ORG_STRUC.firstGeneSplit(i,:));
                end
            end
            k = 1 + floor(rand*size(tmp,1));
            POP_STRUC.POPULATION(it).numBlocks = tmp(k,:);
        end
    end
    spl = spl + 1;
end

% The variable defining number of structures in first generation to be generated with symmetry random
% the rest of structures wil be generated with topological random
howManyRandFirstGen = ORG_STRUC.fracRand/(ORG_STRUC.fracRand+ORG_STRUC.fracRandTop)*ORG_STRUC.initialPopSize;

for it = 1 : IPS
    POP_STRUC.POPULATION(it).numIons = POP_STRUC.POPULATION(it).numBlocks*ORG_STRUC.numIons;
    if it <= howManyRandFirstGen
        [candidate, lat] = Random_Init_301(it, POP_STRUC.POPULATION(it).numBlocks,0);%0 - symmetry based random
        POP_STRUC.POPULATION(it).howCome = '  Random  ';
    else
        [candidate, lat] = Random_Init_301(it, POP_STRUC.POPULATION(it).numBlocks,1);%1 - topological random
        POP_STRUC.POPULATION(it).howCome = '  RandTop  ';
    end
    POP_STRUC.POPULATION(it).LATTICE = lat;
    POP_STRUC.POPULATION(it).COORDINATES = candidate;
end

if ORG_STRUC.wrong_spacegroups > 0
    disp([' ']);
    disp(['ATTENTION! In ' num2str(ORG_STRUC.wrong_spacegroups) ' / ' ...
        num2str(ORG_STRUC.initialPopSize) ' cases actually generated symmetry was different.']);
    disp([' ']);
end

disp(' ');
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if ORG_STRUC.spin == 1
    for i = 1: ORG_STRUC.initialPopSize
        POP_STRUC.POPULATION(i) = individual_Spin_Init(  POP_STRUC.POPULATION(i) );
    end
end

%%%%%%%%%%%%%%%%%%%% START SEEDING %%%%%%%%%%%%%%%%%
%pick_Seeds();
pickUpSeeds();
if ORG_STRUC.doFing
    pickAntiSeeds();
end
Start_POP();
