function initialize_POP_STRUC_311()

% USPEX Version 9.3.0
% Change: variable composition added
global ORG_STRUC
global POP_STRUC
global POOL_STRUC

POOL_STRUC = struct('POPULATION',{}, 'Composition_ratio',{}, 'Composition_ranking',{}, ...
                     'Composition_surviving',{}, 'Composition_Bestenthalpy',{}, 'Composition_fitness',{});
POOL_STRUC(1).POPULATION  = struct('COORDINATES', {}, 'LATTICE', {}, 'numIons', {}, 'numMols', {}, ...
                            'MOLECULES', {}, 'numBlocks',{}, 'order', {}, 'enthalpy', {}, 'Number', {});
POOL_STRUC.POPULATION(1) = QuickStart(POOL_STRUC.POPULATION);
for i=1:size(ORG_STRUC.numIons,1)
    POOL_STRUC.Composition_ratio(i,:) = ORG_STRUC.numIons(i,:)/sum(ORG_STRUC.numIons(i,:));
    POOL_STRUC.Composition_ranking(i) = 0;
    POOL_STRUC.Composition_surviving(i) = 1;
    POOL_STRUC.Composition_Bestenthalpy(i) = 1000;
    POOL_STRUC.Composition_fitness(i) = 1000;
end
POP_STRUC = struct('POPULATION',{}, 'SOFTMODEParents',{}, 'SOFTMUTATED',{}, ...
'resFolder', {},'generation',{}, 'DoneOrder',{}, 'bodyCount', {}, 'ranking',{},...
'bad_rank',{},  'CalcFold',{}, 'CalcFold_max',{}, 'fitness', {}, 'convex_hull',{});

POP_STRUC(1).POPULATION = struct('COORDINATES',{},'INIT_COORD',{},'LATTICE',{},'INIT_LAT',{},'INIT_numIons',{},'MOLECULES',{},'order',{},...
'struc_entr',{},'S_order',{},'FINGERPRINT',{},'K_POINTS',{},'Step', {},'Enthalpies', {},'Error',{},'Done',{},'ToDo',{},'Parents',{},...
'howCome',{},'JobID',{},'Folder',{},'numIons', {}, 'numBlocks', {}, 'numMols', {}, 'MtypeLIST',{}, 'typesAList',{},'Number',{},'symg', {});
POP_STRUC.POPULATION(1) = QuickStart(POP_STRUC.POPULATION);

POP_STRUC(1).POPULATION(1).MOLECULES=struct('MOLCOORS',{},'ZMATRIX',{},'ID',{},'MOLCENTER',{},'order',{});
POP_STRUC(1).SOFTMUTATED = struct('FINGERPRINT',{}, 'mutatedAt', {}, 'fallBack', {});
POP_STRUC(1).SOFTMODEParents=struct('lattice',{},'coordinates',{},'molecules',{},'fingerprint',{},'molfingerprint',{},'eignFre',{},'eignVec',{},'Softmode_Fre',{},'Softmode_num',{},'numIons',{},'numBlocks',{});

POP_STRUC.generation = 1;
POP_STRUC.bodyCount = 0;
POP_STRUC.bad_rank = 0;

N_T = size(ORG_STRUC.numMols,1);
IPS = ORG_STRUC.initialPopSize;

fp = fopen('Seeds/compositions', 'w');
for i=1:size(ORG_STRUC.firstGeneSplit,1)
      for j=1:size(ORG_STRUC.firstGeneSplit,2)
            fprintf(fp, '%4d', ORG_STRUC.firstGeneSplit(i,j));
      end
      fprintf(fp, '\n');
end
fclose(fp);

if (ORG_STRUC.firstGeneMax == 0) || (ORG_STRUC.firstGeneMax > IPS)
   ORG_STRUC.firstGeneMax = IPS;
end
if (ORG_STRUC.firstGeneMax > ORG_STRUC.splitN)
   ORG_STRUC.firstGeneMax = ORG_STRUC.splitN;
end
split_rank_temp = randperm(ORG_STRUC.splitN);
split_rank = split_rank_temp;

% we want only different compositions, including all single block compositions
% single elements:
for it = 1 : N_T
 for jt = 1 : ORG_STRUC.splitN
  if sum(ORG_STRUC.firstGeneSplit(split_rank_temp(jt),:)) == ORG_STRUC.firstGeneSplit(split_rank_temp(jt),it)
    split_rank(it) = split_rank_temp(jt);
    split_rank(jt) = split_rank_temp(it);
    split_rank_temp = split_rank;
    break;
  end
 end
end
% identical compositions are moved away till we reach firstGeneMax different ones
cnt = N_T;
split_rank_temp = split_rank;
for it = 1 : ORG_STRUC.splitN
 good_comp = 1; 
 for jt = 1 : cnt
  same = sameComposition(ORG_STRUC.firstGeneSplit(split_rank(jt),:), ORG_STRUC.firstGeneSplit(split_rank_temp(it),:));
  if same == 1
    good_comp = 0;
  end
 end
 if (good_comp == 1) && (size(ORG_STRUC.firstGeneSplit,1) - it) <= (ORG_STRUC.firstGeneMax - cnt)
   good_comp = 1;
 end
 if good_comp == 1
  cnt = cnt + 1;
  split_rank(cnt) = split_rank_temp(it);
  split_rank(it) = split_rank_temp(cnt);
 end
 if cnt >= ORG_STRUC.firstGeneMax
   break;
 end
end 
% at this stage we have firstGeneMax different compositions at the beginning of the population and then whatever was generated by randperm

if ORG_STRUC.firstGeneMax < N_T    % if we found almost no compositions due to strict min/maxAt - at least do all single block ones
  ORG_STRUC.firstGeneMax = N_T;
end   

% vary the number of formula units in the unit cell for same position on the convex hull
% change the algorithm as soon as the number of possible compositions is big enough to slow it down
spl = 1;
for it = 1 : IPS
  while spl > ORG_STRUC.firstGeneMax
    spl = spl - ORG_STRUC.firstGeneMax;
  end
  POP_STRUC.POPULATION(it).numBlocks = ORG_STRUC.firstGeneSplit(split_rank(spl),:);
  % exclude the case of two identical blocks
  % add an element of randomness; numIons for single element compositions can be anything between maxAt and minAt now:
  if N_T > 1      
   if spl <= N_T 
    POP_STRUC.POPULATION(it).numBlocks = zeros(1, N_T); %make sure single block is always single block
    POP_STRUC.POPULATION(it).numBlocks(spl) = round(ORG_STRUC.minAt/sum(ORG_STRUC.numIons(spl,:)))...
                   + round(rand*((ORG_STRUC.maxAt-ORG_STRUC.minAt)/sum(ORG_STRUC.numIons(spl,:))));
    while sum(POP_STRUC.POPULATION(it).numBlocks(spl)*ORG_STRUC.numIons(spl,1:end)) > ORG_STRUC.maxAt
       POP_STRUC.POPULATION(it).numBlocks(spl) = POP_STRUC.POPULATION(it).numBlocks(spl) - 1;
       if POP_STRUC.POPULATION(it).numBlocks(spl) < 0
         break;
       end
    end
    if POP_STRUC.POPULATION(it).numBlocks(spl) < 1
      POP_STRUC.POPULATION(it).numBlocks(spl) = 1;
    end
   else % add an element of randomness if possible
    tmp = POP_STRUC.POPULATION(it).numBlocks;
    for i = 1 : ORG_STRUC.splitN
     same = sameComposition(POP_STRUC.POPULATION(it).numBlocks, ORG_STRUC.firstGeneSplit(i,:));
     if same == 1
       tmp = vertcat(tmp,ORG_STRUC.firstGeneSplit(i,:));
     end
    end
    k = 1 + floor(rand*size(tmp,1));
    POP_STRUC.POPULATION(it).numBlocks = tmp(k,:);
   end
  end
  spl = spl + 1;
end

for it = 1 : IPS

  numMols = POP_STRUC.POPULATION(it).numBlocks*ORG_STRUC.numIons;
  POP = Random_Init_311(it, numMols);
  POP_STRUC.POPULATION(it).MOLECULES  = POP.MOLECULES;
  POP_STRUC.POPULATION(it).numMols    = POP.numMols;
  POP_STRUC.POPULATION(it).MtypeLIST  = POP.MtypeLIST;
  POP_STRUC.POPULATION(it).typesAList = POP.typesAList;
  POP_STRUC.POPULATION(it).numIons    = POP.numIons;
  POP_STRUC.POPULATION(it).LATTICE    = POP.LATTICE;
  POP_STRUC.POPULATION(it).howCome    = '  Random  ';

end

pickUpSeeds();
Start_POP();

