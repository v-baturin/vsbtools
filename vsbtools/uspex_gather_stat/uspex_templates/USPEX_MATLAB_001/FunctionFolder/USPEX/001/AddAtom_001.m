function AddAtom_001(Ind_No)

% USPEX Version 10.1
global POP_STRUC
global ORG_STRUC
global OFF_STRUC
global AR_VARIANTS
global CLUSTERS

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%% CREATING offspring by adding atom %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

goodMutant = 0;
goodMutLattice = 0;
goodComposition = 0;

count = 0;
while goodComposition + goodMutant + goodMutLattice  ~= 3
    [whichStructure, whichAtom, whichAtom2, whichEdge, typeAtom_add] = find_candidate_add();
    
    count = count + 1;
    if (count > 1000) || (whichStructure == -1)
        %disp('failed to do addAtom in 1000 attempts, switch to Random');
        USPEXmessage(508,'',0);
        Random_001(Ind_No);
        break;
    end
    
    ind = POP_STRUC.ranking(whichStructure);
    [goodComposition, COORD, numIons, LATTICE] = AddAtom(whichStructure, whichAtom, whichAtom2, typeAtom_add);
    
    if goodComposition == 1
        goodMutant = distanceCheck(COORD,LATTICE,numIons,ORG_STRUC.minDistMatrice);
        if goodMutant == 1
            goodMutant = checkConnectivity(COORD,LATTICE,numIons);
        end

       if goodMutant == 1
          goodMutant = CheckOldOffspring(LATTICE, COORD, numIons, Ind_No, 'AddAtom_001');
       end
        
        goodMutLattice = 1; % since removing atom doesn't change it
        
        if goodMutant + goodMutLattice == 2
            OFF_STRUC.POPULATION(Ind_No).COORDINATES =  COORD;
            OFF_STRUC.POPULATION(Ind_No).LATTICE = LATTICE;
            OFF_STRUC.POPULATION(Ind_No).howCome = 'AddAtom';
            
            info_parents = struct('parent', {},'enthalpy', {});
            info_parents(1).parent = num2str(POP_STRUC.POPULATION(ind).Number);
            info_parents.enthalpy  = POP_STRUC.POPULATION(ind).Enthalpies(end)/sum(POP_STRUC.POPULATION(ind).numIons);
            OFF_STRUC.POPULATION(Ind_No).Parents = info_parents;
            OFF_STRUC.POPULATION(Ind_No).numIons = numIons;
            disp(['Structure ' num2str(Ind_No) ' generated by addAtom; count=' num2str(count) ' ind=' num2str(ind) ' atom=' num2str(whichAtom)]);
        end
    end
    
    % now we write information in AR_VARIANTS and CLUSTERS structures
    % number of current structure in CLUSTERS database:
    i_clusters = AR_VARIANTS.number(whichStructure);
    
    if goodComposition == 0 %in this case probabilities of adding new atom of the selected type for all atoms and edges = 0
        for j = 1 : length(AR_VARIANTS.Structure(whichStructure).Atom)
            for k = 1 : length(AR_VARIANTS.Structure(whichStructure).Atom(j).Edge)
                AR_VARIANTS.Structure(whichStructure).Atom(j).Edge(k).add(typeAtom_add) = 0;
                CLUSTERS.Structure(i_clusters).Atom(j).Edge(k).add(typeAtom_add) = 0;
            end
        end
    else
        if goodMutant + goodMutLattice == 2 %we find good offspring - probabilities of adding new atom near all edges of the current atom = 0
            sim_atoms = find_similar_atoms(whichStructure, whichAtom);
            for j = 1 : length(sim_atoms)
                for k = 1 : length(AR_VARIANTS.Structure(whichStructure).Atom(sim_atoms(j)).Edge)
                    AR_VARIANTS.Structure(whichStructure).Atom(sim_atoms(j)).Edge(k).add(typeAtom_add) = 0;
                    CLUSTERS.Structure(i_clusters).Atom(sim_atoms(j)).Edge(k).add(typeAtom_add) = 0;
                    
                    %do the same for linked (conjugate) atoms
                    [Atom_conj, Edge_conj] = find_conjAtomEdge(whichStructure, sim_atoms(j), k);
                    if (Edge_conj~=-1)
                        AR_VARIANTS.Structure(whichStructure).Atom(Atom_conj).Edge(Edge_conj).add(typeAtom_add) = 0;
                        CLUSTERS.Structure(i_clusters).Atom(Atom_conj).Edge(Edge_conj).add(typeAtom_add) = 0;
                    end
                end
            end
            
            sim_atoms2 = find_similar_atoms(whichStructure, whichAtom2);
            for j = 1 : length(sim_atoms2)
                for k = 1 : length(AR_VARIANTS.Structure(whichStructure).Atom(sim_atoms2(j)).Edge)
                    AR_VARIANTS.Structure(whichStructure).Atom(sim_atoms2(j)).Edge(k).add(typeAtom_add) = 0;
                    CLUSTERS.Structure(i_clusters).Atom(sim_atoms2(j)).Edge(k).add(typeAtom_add) = 0;
                    
                    %do the same for linked (conjugate) atoms
                    [Atom_conj, Edge_conj] = find_conjAtomEdge(whichStructure, sim_atoms2(j), k);
                    if (Edge_conj~=-1)
                        AR_VARIANTS.Structure(whichStructure).Atom(Atom_conj).Edge(Edge_conj).add(typeAtom_add) = 0;
                        CLUSTERS.Structure(i_clusters).Atom(Atom_conj).Edge(Edge_conj).add(typeAtom_add) = 0;
                    end
                end
            end            
        else %not good offspring - probability of adding new atom near the current atom and edge = 0
            AR_VARIANTS.Structure(whichStructure).Atom(whichAtom).Edge(whichEdge).add(typeAtom_add) = 0;
            CLUSTERS.Structure(i_clusters).Atom(whichAtom).Edge(whichEdge).add(typeAtom_add) = 0;
               
            %do the same for linked (conjugate) atoms
            [Atom_conj, Edge_conj] = find_conjAtomEdge(whichStructure, whichAtom, whichEdge);
            if (Edge_conj~=-1)
                AR_VARIANTS.Structure(whichStructure).Atom(Atom_conj).Edge(Edge_conj).add(typeAtom_add) = 0;
                CLUSTERS.Structure(i_clusters).Atom(Atom_conj).Edge(Edge_conj).add(typeAtom_add) = 0;
            end
        end
    end
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%% END creating offspring %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
