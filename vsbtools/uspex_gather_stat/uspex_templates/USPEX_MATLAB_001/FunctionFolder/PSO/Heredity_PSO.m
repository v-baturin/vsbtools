function Heredity_PSO(Ind_No)

global POP_STRUC
global ORG_STRUC
global OFF_STRUC

info_parents = struct('parent', {}, 'fracFrac', {},'dimension', {},'offset', {},'enthalpy', {});
searching = 1;
count = 1;

while searching
    count = count + 1;
    if count > 50
        %disp('failed to do Heredity in 50 attempts, switch to Random');
        USPEXmessage(507,'',0);
        Random_PSO(Ind_No);
        break;
    end
    % choose one set of parents
    % We select randomly a dimension used for the spacial criteria of the heredity
    dist1 = cosineDistance(POP_STRUC.POPULATION(Ind_No).FINGERPRINT, POP_STRUC.PSO(Ind_No).fingerprint, ORG_STRUC.weight);
    dist2 = cosineDistance(POP_STRUC.POPULATION(Ind_No).FINGERPRINT, POP_STRUC.PSO(POP_STRUC.bestPSOstruc).fingerprint, ORG_STRUC.weight);
    tmp = rand*(ORG_STRUC.PSO_BestStruc*dist1 + ORG_STRUC.PSO_BestEver*dist2);
    if tmp <= ORG_STRUC.PSO_BestEver*dist2   % breed with best ever
        par_one = 0;
        par_two = Ind_No;
    else                                     % breed with best in the structure history
        par_one = Ind_No;
        par_two = Ind_No;
    end
    %wait for suitable offspring (offspring fulfilling hard constraints)
    goodHeritage = 0;
    goodLattice = 0;
    securityCheck = 0;
    while goodHeritage + goodLattice ~=2
        
        securityCheck = securityCheck+1;
        offset=[];
        dimension = RandInt(1,1,[1,3]);
        [numIons, potentialOffspring, potentialLattice,fracFrac,dimension,offset]= heredity_final(par_one, par_two);
        % optimize the lattice
        if ~ORG_STRUC.constLattice
            coord = potentialOffspring*potentialLattice;
            [coord, potentialLattice] = optLattice(coord, potentialLattice);
            potentialOffspring = coord/potentialLattice;
        end
        
        goodHeritage = distanceCheck(potentialOffspring, potentialLattice, numIons, ORG_STRUC.minDistMatrice);
        goodLattice = latticeCheck(potentialLattice);
        
        if goodHeritage + goodLattice  == 2
            OFF_STRUC.POPULATION(Ind_No).COORDINATES = potentialOffspring;
            OFF_STRUC.POPULATION(Ind_No).LATTICE = potentialLattice;
            searching=0;
            ID2 = POP_STRUC.POPULATION(par_two).Number;
            if par_one == 0
                ID = [POP_STRUC.PSO(POP_STRUC.bestPSOstruc).Number ID2];
                info_parents(1).parent  =   num2str(ID); % 0 = PSO with absolute best
                info_parents.enthalpy = POP_STRUC.PSO(POP_STRUC.bestPSOstruc).enthalpy*fracFrac + POP_STRUC.POPULATION(par_two).Enthalpies(end)*(1-fracFrac);
                OFF_STRUC.POPULATION(Ind_No).howCome = 'Heredity-g';
            else
                ID = [POP_STRUC.PSO(par_two).Number ID2];
                info_parents(1).parent  =  num2str(ID); % - = PSO with best in the structure history
                info_parents.enthalpy = POP_STRUC.PSO(par_two).enthalpy*fracFrac + POP_STRUC.POPULATION(par_two).Enthalpies(end)*(1-fracFrac);
                OFF_STRUC.POPULATION(Ind_No).howCome = 'Heredity-l';
            end
            
            info_parents.fracFrac=fracFrac;
            info_parents.dimension=dimension;
            info_parents.offset=offset;
            OFF_STRUC.POPULATION(Ind_No).Parents = info_parents;
            OFF_STRUC.POPULATION(Ind_No).numIons = numIons;
            disp(['Structure ' num2str(Ind_No) ' generated by heredity']);
            
        elseif securityCheck > 100
            disp('Cannot produce good Offspring within 100 attempts, switch to mutation')
            Mutation_PSO(Ind_No);
            searching=0;
            goodLattice = 1;
            goodHeritage = 1;
        end
    end
end
