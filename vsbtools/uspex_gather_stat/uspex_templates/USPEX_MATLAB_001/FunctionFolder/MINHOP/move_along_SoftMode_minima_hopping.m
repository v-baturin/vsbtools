function [new_Lattice, new_Coord, deviation]= move_along_SoftMode_minima_hopping(coord, numIons, old_lattice, eigvector, mut_degree, mutationRate)
global ORG_STRUC
global OFF_STRUC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if ORG_STRUC.constLattice ~= 1
if length(old_lattice)==6
 old_lattice = latConverter(old_lattice);
end
new_Lattice=[];
dummy = 1;
while det(new_Lattice)<0.01 || dummy 
   if ORG_STRUC.dimension == 0
    dummy = 0;
    strainMatrix = zeros(3);
    epsilons = randn(6,1)*mutationRate;
    strainMatrix(1,1) = 1+epsilons(1);
    strainMatrix(2,2) = 1+epsilons(2);
    strainMatrix(3,3) = 1+epsilons(3);
    strainMatrix(1,2) = 0;
    strainMatrix(2,1) = 0;
    strainMatrix(1,3) = 0;
    strainMatrix(3,1) = 0;
    strainMatrix(2,3) = 0;
    strainMatrix(3,2) = 0;
   else 
    dummy = 0;
    strainMatrix = zeros(3);
    epsilons = randn(6,1)*mutationRate;
    strainMatrix(1,1) = 1+epsilons(1);
    strainMatrix(2,2) = 1+epsilons(2);
    strainMatrix(3,3) = 1+epsilons(3);
    strainMatrix(1,2) = epsilons(4)/2;
    strainMatrix(2,1) = epsilons(4)/2;
    strainMatrix(1,3) = epsilons(5)/2;
    strainMatrix(3,1) = epsilons(5)/2;
    strainMatrix(2,3) = epsilons(6)/2;
    strainMatrix(3,2) = epsilons(6)/2;
   end
 new_Lattice = old_lattice*strainMatrix;
end

temp_potLat = new_Lattice;


volLat = det(temp_potLat);
if sign(volLat)==-1
      %%%%%%%%%%%%%%%%It cannot happen, but just for safety!!!
      disp('the determinant of the lattice generated by lattice mutation is negative'); 
end
    
 % scale the lattice to the volume we asume it approximately to be
if ORG_STRUC.varcomp == 1 
 % 7.2.7 change - leave it the same as parent volume
 %       latVol = 0;
 %       for it = 1 : length(ORG_STRUC.latVolume)
 %          latVol = latVol + numIons(it)*ORG_STRUC.latVolume(it);
 %        end
       latVol = det(old_lattice);
else
%       latVol = ORG_STRUC.latVolume;
        latVol = det(old_lattice);
end

ratio = latVol/volLat;
temp_potLat = latConverter(temp_potLat);
temp_potLat(1:3)= temp_potLat(1:3)*(ratio)^(1/3);
new_Lattice = latConverter(temp_potLat);
OFF_STRUC.lat = new_Lattice;
   elseif ORG_STRUC.constLattice == 1
   new_Lattice = old_lattice;
   %disp('fixed cell enabled')
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

N = sum(numIons);
vec = zeros(1,3);
new_Coord = coord;
%lat = lattice;

vect = zeros(1,3);
R_val = zeros(1,length(ORG_STRUC.atomType));
for i = 1 : length(ORG_STRUC.atomType)
 s = covalentRadius(ORG_STRUC.atomType(i));
 R_val(i) = str2num(s);
end
at_types = zeros(1,N);
for k = 1 : N
   tmp = k;
   while tmp > 0
     at_types(k) = at_types(k) + 1;
     tmp = tmp - numIons(at_types(k));
   end
end                                                  % END this part needed for clusters

if length(old_lattice) == 6
 old_lattice = latConverter(old_lattice);
end

coef = 0;
for i = 1 : N
  vec(1) = eigvector((i-1)*3+1);
  vec(2) = eigvector((i-1)*3+2);
  vec(3) = eigvector((i-1)*3+3);
  if norm(vec) > coef
   coef = norm(vec);
  end
end
normfac = mut_degree/coef;   % this way the maximal displacement for an atom is equal to howManyMut*mut_degree
notDone = 1;
step = 0;

while notDone
 for i = 1 : N                      % shift the atoms
   vec(1) = eigvector((i-1)*3+1);
   vec(2) = eigvector((i-1)*3+2);
   vec(3) = eigvector((i-1)*3+3);
   new_Coord(i,:) = coord(i,:) + normfac*vec*inv(old_lattice);
   new_Coord(i,1) = new_Coord(i,1) - floor(new_Coord(i,1));
   new_Coord(i,2) = new_Coord(i,2) - floor(new_Coord(i,2));
   new_Coord(i,3) = new_Coord(i,3) - floor(new_Coord(i,3));
   deviation(i) = norm(normfac*vec);
 end
  notDone = 0;
 if step > 10
  notDone = 0;
 end
end
